#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'edu_domoi.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

'''
    Здесь буду писать всё о структуре джанги в целом

    Проект состоит из приложений (App), которые представляют
    из себя отдельный кусок функционала, изолированное приложение

    Приложение = папка с исходниками внутри
    По хорошему, приложения должны работать независимо друг от друга
    что логично, ведь мы захотим их переносить из одного проекта в другой

    создать свое приложение можно так:
    python manage.py startapp <название_приложения>
    (выполнять в активной директории с manage.py)

    В джанго реализован паттерн MVC
    Model - View - Controller
    Код для описания данных в бд - модели
    Маршрутизация генерации ответа пользователю - вьюшка
    Код, маршрутизирующий и обрабатывающий запросы - контроллер

    А за обработку запроса отвечает только файл Views, то есть
    весь контроль отображения шаблонов реализован со вьюшками

    Мы будет использовать sqlite
    Данные в базах данных хранятся в таблицах, где в столбцах
    содержаться поля сущностей, а в каждой строке - обособленная
    сущность, ничего нового.

    Общение с базой данных, обычно, происходит с помощью sql
    запросов напрямую, но джанго поднимает и это на один
    уровень вверх и для обмена информацией с данных мы будем
    пользоваться ORM (Object Relational Mapping)

    Перевод на русский (объекто-реляционное отображение)
    Суть слова меппинг - процесс соотнесения "карты и территории"

    вместо карты - объекты python, а вместо территории - базы данных
    бд соответственно реляционная

    Джанго позволяет представить записи и их свойства в виде
    объектов Python, и работу с самой базой средствами абстракции
    ООП - классами и их методами.

    Да, можно было бы вручную закодить вызов запросов и параметров,
    но вот если база данных поменяется, сложные запросы приходится
    переписать

    Суть ORM в том, чтобы не было проблем при смене БД
        
    ----------
    Кастомный CSS
    Для начала, создадим папку static на уровне проекта.
    В ней будут хранится файлы, содержание которых не изменяется
    в процессе работы (css, js, медиа)
    Там создадим отдельную папку для css
    Всё остальное описание будет внутри файла styles.css

    ----------
    Модели описываются в model.py
    Вьюшки в views.py
    Обработку перехода на узел и вызов соответствующей вьюшки осуществялет urls.py
    Всякие вспомогательные приколы типа миксинов есть в utils.py
    Формы, которые используются за получения данных и которые можно соотнести с 
    моделями - в forms.py

    А этот файл (manage.py) представляет собой некий интерфейс, позволяющий контролировать
    и настраивать работу кода.


    ----------
    Ограничение доступа к страницам
    Сделаем мы это на уровне вьюшек вместе с редиректами
    Описание всего процесса просиходит в views.py основного приложения проекта

    ----------
    Пагинация (постраничная навигация)
    Достаточно распространённая тема, реализовать её можно по разному.
    Я бы, например, просто брал слайсы из передаваемого массива ссылок на
    объекты нужной модели или просто класса, и передавал бы их во внутренний
    контекст, а параметры для слайсов определял на основе номера страницы.

    Но это не особо важно, потому-что в джанго уже реализован паджинейтор,
    он содержится в основном модуле, django.core.paginator, в классе
    Paginator.

    С ним можно поиграться в REPL режиме, вызвав шелл через manage.py
    Работает этот класс достаточно просто:

    Сначала создадим экзеспляр класса, передав в конструктор следующие вещи:
    Первый аргумент: QuerySet, который мы можем получить, обратившись к классу
    модели, импортировав её и обратившись к методу objects.all(), пусть
    для примера будет без параметров.

    Второй аргумент: количество элементов на каждой странице

    Если мы в репл-режиме сделаем это, то джанга скорее всего заругается на
    нас и скажет, что порядок постов может быть неопределён.

    Чтобы исправить это, в модели добавим соответствующий класс Meta,
    описывающий, как нужно взаимодействовать с его объектами,
    определить внутри атрибут, равный списку со строкой, значение которой
    должно совпадать с одним из названий атрибутов SQL, по которой бы объекты
    сортировались.
    Т.е. что-то похожее должно было бы выйти:
    class Meta:
        ordering = ["-date_pub"]
    Прямо внутри класса модели, да

    Кстати, сам атрибут без минуса, этот минус просто указывает, что сортировка
    пусть будет в обратном порядке, т.е. сначала новая дата.

    Да, вернётся объект класса с атрибутами, которые мы можем посмотреть
    через dir()

    Например, get_page, который вернёт объект класса Page, у которого тоже
    свои атрибуты, в том числе object_list, в котором все нужные нам
    объекты.

    Обычно, когда мы бегаем по страницам, на сайтах с пагинацией
    ссылка приобретает следующий вид:
    http://127.0.0.1:8000/blog/?page=2
    или вместо двойки любой другой номер.
    После знака вопроса идёт параметр GET запроса, сами параметры
    разделяются знаком амперсанты

    Мы воспользуемся этой темой, чтобы не городить в коде кринж.
    Чтобы обратиться к параметру запроса, достаточно написать
    такой код: page_number = request.GET.get('page', 1)
    (это если объект request представляет реквест)
    Второй параметр - дефолтное значение

    Теперь, остается теперь только менять этот параметр!
    Нам достаточно привязать к кнопкам ссылку, которые будут
    отправлять запрос с новым параметром-страницей

    Но, также нам нужно привязать количество кнопок к количеству
    страниц, т.е. саму верстку изменить так, чтобы на неё отражалась
    логика кода.

    А для этого воспользуемся другим атрибутом: page_range
    Все подробности реализации в шаблоне, где выводятся посты
    (index.html, который идёт от вьюшки post_list)

    Ещё важная отметка: объект page хранит в себе ссылку на пагинатор,
    чтобы какие-то детали реализации выглядели проще и не надобность
    передавать в контекст шаблона сам пагинатор отпала
'''