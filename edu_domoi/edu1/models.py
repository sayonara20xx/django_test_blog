"""
    Описываю здесь всё связанное со взаимодействием с бд
    и созданием моделей

    Модель - объект, который абстрагирует SQL запросы
    при работе с django

    Они не особо сложно описываются, пример снизу
    Параметры создаваемых экземпляров полей интереснее

    С макс длиной всё понятно
    Индексация применяется для более быстрого поиска
    Уникальность тоже понятно, uniqie автоматически индексируются
    Blank - допустимо ли оставлять поле пустым,

    У даты и времени мы определили два именованных параметра:
    auto_now_add - поле заполняется при сохранении объекта в бд
    auto_now - изменение каждый раз при изменении модели

    В принципе, с типами полей (классами полей в models) всё
    понятно по именам, это весь базис для определения ограничений
    целостности

    Слаг - человеко-понятный URL (ЧПУ) (а?)
    Их смысл в том, чтобы уникально идентифицировать
    объект по урлу, но ещё и так, чтобы человек мог
    оценить URL визуально и понять, попадёт ли он
    куда нужно или нет
    SlugField тот же чарфилд, но разрежшает использовать
    только буквы, цифры, _ и -, остальное нельзя

    Переопределяем метод __str__, чтобы при попытке выяснить
    что вернула программа она выдала тайтл записи, а не объект
    какого класса что это

    Чтобы создать таблицы по модели и внесения измений в БД
    вообще мы используем миграции

    Миграции в джанго - подобие гита, но именно для бд,
    контроль версий бд - это соотнесение то, что есть, и то,
    что должно быть на текущий момент по моделям

    Чтобы скормить модель, нужно вызвать manage.py с аргументом
    makemigrations

    Файлы миграции создадустя, чтобы внести изменения, делаем
    то же самое, но с параметром migrate

    Чтобы создать объекты класса модели, можно зайти в шелл через manage.py
    и там, предварительно импортировав из edu1.models нашу модель
    через конструкторы играть с бд

    p = Post(title="NewPost1", slug="new-slug1", body="body1")

    Стейтмент выже создаст нам объект той модели, что мы описали здесь
    У него не будет айди: он появится, когда мы его сохраним в бд с
    помощью:
    p.save()

    Джанго при создании модели прибавляет к нему менеджера модели
    Если мы посмотрим dir(p) (атрибуты в классе экземпляра), то
    там будет атрибут objects, через которую осуществляется
    внесение изменений в бд

    То есть, вот аналог save:
    p1 = Post.objects.create(title="NewPost2", slug="new-slug2", body="body2")
    
    Чтобы посмотреть все объекты, идем туда же к all
    Post.objetcs.all() вернёт QuerySet, которые ведёт себя почти как список

    Чтобы получить данные из БД, идем к тому же атрибуту:
    p3 = Post.objects.get(slug="new-slug1")

    В метод мы должны передать идентифицирующий объект модели
    
    Лайфхак, чтобы сделать метод нечуствительным к регистру,
    используем лукапы (штуки джанги, которые сужают круг поиска)
    p3 = Post.objects.get(slug__iexact="New-slug1")
    lookup пишется через два нижних подчёркивания, именно этот описывает
    нечуствительность к регистру и точное совпадение (i - insensetive)
    Есть ещё полезный лукап __contains

    Если метод может вернуть несколько объектов, лучше использовать
    filter, который вернёт нам QuerySet

    Чтобы во вьюхах использовать данные из моделей, импортируем
    класс отсюда в файл views

    ---------
    Чтобы упростить себе жизнь при использовании url внутри
    html-исходников, определим метод get_absolute_url,
    который джанго использует

    он создает ссылку на страницу по слагу, такой процесс называется
    реверсингом

    По сути, мы регенерируем ссылку на этот объект, которая определяется
    слагом

    reverse в исходниках питона - это аналог url в исходниках html
    Тогда вместо {% url ... %} используем {{ post.get_absolute_url }}
    где "post" - имя контекстной переданной переменной.

    получаем то же самое, но не захломляем html доки

    -------
    Теги

    Задача тегов состоит в задании категоризации/классификации,
    разбиения экземпляров класса в группы по тегам

    У одного экземпляра может быть много тегов, и у тега
    может быть множество постов, MtM отношение

    Да, теги здесь просто формальная модель, которая
    служит примером, показывающим, как реализовать реляционное
    отношение в джанго

    так как отношение "много ко многому", и ключевым полем у
    айдишников мы поставим так же просто уникальный айди, то
    можно представить всё примерно следующим образом:
    tag_id post_id
    1      1
    1      2
    2      1
    2      3

    и так далее

    В джанго с созданием таких таблиц попроще, чем, например,
    во фласке
    Реляционное отношение устанавливается в процессе создания
    модели и указания там соответствующих параметров в
    экземплярах типов данных
    Пример представлен ниже в классе Tag

    Само отношение неважно где указывать, можно и там и там
    писать models.ManytoManyField, просто немного меняется
    логика работы
    blank позволяет сделать пустые привязки и пустые свойства
    в таблицах, т.е. пост может быть и без тегов
    related_name указывает имя появляющегося у связываемого
    класса с указанным первым параметром именем свойства, которое
    будет хранить экземпляры класса исходного

    т.е. появится свойство, которое позволит нам посмотреть,
    какие посты к каким тегам привязаны
    Если явно не указать имя, то оно будет иметь имя Posts_set,
    его сделает джанга сама

    как и с постом, мы можем поиграться с экземплярами этого класса
    в шелле
    Чтобы связать тег с постом, для начала стоит посмотреть все данные
    о постах, с помощью метода values() в поле objects класса Post

    Чтобы добавить теги с помощью менеджера, достаточно обратиться
    к онному в экземпляре класса Post (тут уже без objects, т.к. 
    отношение задано)
    т.е. чтобы прикрепить к посту тег, достаточно написать:
    post.tags.add(django_tag)

    и post, и параметр - экземпляры своих классов

    -- Генерация слагов --
    у джанго уже предусмотрена "слагификация"
    функция slugify лежит в django.utils.text
    нужна она нам чтобы сделать слаги предварительно валидными и не
    парить пользователя в случае чего


    -- Автоизменение данных при изменении экземпляров --
    Делается это с помощью переопределения методы save у
    моделей

    используется именно такая перегрузка:
    save(self, *args, **kwargs)

    в данном случае, я просто дополнил то, что написано
    в классе Model, передав все аргументы через super()
    туда же
    (это как если я в плюсах через двоеточие буду обращаться
    к конструкторам родительских классов внутри дочерних, чтобы
    не повторять уже описанную там логику, но здесь про методы речь)

    использую фишку про то, что у ещё несохранённых в бд объектов
    нету id, чтобы юзать генератор только для вновь созданных

    Да, во избежании исключений необходимо добавить 
    проверку заполнения всех используемых полей


    -- Метод get_update_url --
    Связано его появление с тем, что джанго не могла собрать
    через реверс путь до формы модификации тега, так как в пути
    был слаг, передаваемый через параметр.

    его вызов в таком виде:
    {{ tag.get_update_url }}
    отсылал нас к тому, что мы определяли в юрлсах и с параметром
    всё было в порядке.

    Можно было, конечно, написать функцию url так:
    {% url 'tag_update_url' slug=tag.slug %}
    чтобы параметр slug внутри пути, определённого с параметром
    в urls.py подставился здесь, но когда всё делается внутри
    класса - удобнее

    Да и получается то же самое, просто эта подстановка идёт через
    именованный параметр kwargs и метод reverse
"""

from time import time

from django.db import models
from django.db.models.base import Model
from django.db.models.fields import SlugField
from django.shortcuts import reverse

from django.utils.text import slugify

# Create your models here.

def gen_slug(s):
    new_slug = slugify(s, allow_unicode=True)
    return new_slug + "-" + str(int(time() / (24 * 3600)))


class Post(models.Model):
    title = models.CharField(max_length=150, db_index=True)
    slug = SlugField(max_length=150, blank=True, unique=True)
    body = models.TextField(blank=True, db_index=True)

    # установка реляционного отношения
    tags = models.ManyToManyField("Tag", blank=True, related_name="posts")

    date_pub = models.DateTimeField(auto_now_add=True)

    def save(self, *args, **kwargs):
        if not self.id:
            self.slug = gen_slug(self.title)
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("post_detail_url", kwargs={"slug": self.slug})

    def get_delete_url(self):
        return reverse("post_delete_url", kwargs={"slug": self.slug})

    def get_update_url(self):
        return reverse("post_update_url", kwargs={"slug": self.slug})

    def __str__(self):
        return "{}".format(self.title)

class Tag(models.Model):
    title = models.CharField(max_length=50)
    slug = models.SlugField(max_length=50, unique=True)

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse("tag_detail_url", kwargs={"slug": self.slug})

    def get_delete_url(self):
        return reverse("tag_delete_url", kwargs={"slug": self.slug})

    def get_update_url(self):
        return reverse("tag_update_url", kwargs={"slug": self.slug})