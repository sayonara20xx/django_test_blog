from django import forms
from django.core.exceptions import ValidationError
from django.db.models import fields
from django.forms import widgets
from .models import *

class TagForm(forms.ModelForm):
    # ниже если наследник forms.Form
    # title = forms.CharField(max_length=150)
    # slug = forms.SlugField(max_length=150)

    # title.widget.attrs.update({"class": "form-control"})
    # slug.widget.attrs.update({"class": "form-control"})

    class Meta:
        model = Tag # указываем модель
        fields = ["title", "slug"] # указываем необходимые поля
        
        # указываем классы элементов при рендеринге
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "slug": forms.TextInput(attrs={"class": "form-control"})
        }


    def clean_slug(self):
        new_slug = self.cleaned_data["slug"].lower()

        if new_slug == "create":
            raise ValidationError("slug may not be 'Create'")
        if Tag.objects.filter(slug__iexact=new_slug).count():
            raise ValidationError("slug most be unique. This one already exists.")
        
        return new_slug

    # этот метод переопределяется
    # def save(self):
    #     new_tag = Tag.objects.create(title = self.cleaned_data["title"], 
    #                                  slug = self.cleaned_data["slug"]
    #                                  )
    #     return new_tag

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ["title", "slug", "body", "tags"]
        
        widgets = {
            "title": forms.TextInput(attrs={"class": "form-control"}),
            "slug": forms.TextInput(attrs={"class": "form-control"}),
            "body": forms.Textarea(attrs={"class": "form-control"}),
            "tags": forms.SelectMultiple(attrs={"class": "form-control"})
        }

    def clean_slug(self):
        new_slug = self.cleaned_data["slug"].lower()

        if new_slug == "create":
            raise ValidationError("slug cant have name 'create'")
        return new_slug

"""
    Класс Form генерирует для каждого поля генерирует
    html-тег (в терминах джанго они называются ВИДЖЕТАМИ)

    В случае title и slug это будут input-поля, причём у разных
    классов разные типы полей

    Класс Form автоматически очищает и валидацирует данные, которые
    вводятся в упомянутые поля

    Удобный момент - названия классов у моделей и форм для описания
    моделей совпадают, по сути это логично, ведь html-форма - портал
    в бд, пусть и с оговорками, и соответствие бд и полей в форме
    скорее что-то должное к существованию

    Поля, которые заполняются сами, не обязательно должны быть отражены
    в форме

    Работа с формами идёт посредством экземпляров класса, опять через
    шелл мы можем рассмотреть в подробностях, как лучше всего
    представить их в коде

    Отфильтрованные данные можно получить посредством поля cleaned_data
    Свойство is_bound показывает, заполнял ли форму пользователь вообще
    Валидность введённых данных проверяется is_valid

    Создаем экземпляр класса нашей формы и пытаемся её заполнить, объявив
    словарь соответствуюзим образом:
    d = {"title": "", "slug": ""}
    tf = TagForm(d)

    Впринципе, взаимодействие уже отмечено, баунд вернёт истину, а вот
    валидность ложная, почему именно мы можем посмотреть в словаре
    с ошибками: tf.errors (tf - экземпляр класса формы, созданный
    через соответсвующий конструктор)

    Ошибка потому, что поля пустые, но они обязательны к заполнению
    cleaned_data появляется только после заполнения данных (или
    попытки заполнения), очевидно, если данных нет, то и чистить
    нечего, нужна инициализация

    Очищенные данные представлены в виде словаря, где ключ - имя переменной
    в коде, что удобно при работе с моделями, если выстраивать соответствие

    Валидация данных происходит примерно так: джанго вызывает метод is_valid,
    вызывающий clean методы формы, которые вызывают clean методы для очистки
    данных и их валидации. Валидация так же сильно решает, например, в слаг
    филде может быть представлен только определённый алфавит символов, и
    если пользователь введёт что-то ещё, то класс формы кинет исключение.
    Методы валидации вызываются отдельно, после всего данные закидываются
    в чистый словарь

    Мы можем изменить или дополнить поведение очистки и валидации данных.
    SQL-инъекции кстати основаны на уязвимости в валидации данных сервером

    Мы так же хотим, чтобы все значения свойства слага были в нижнем
    регистре, чтобы не было проблем при сортировке в алфавитном порядке.
    Напишем для этого свой clean метод
    Он должен начинаться с "clean_" согласно соглашению
    Ниже представлен пример такового
    Так же, в клине приводятся обработки исключений, чтобы сообщить
    пользователю о невалидности данных предусмотренным полем ошибки,
    а не дефолтным джанговским или браузерным окном
    Пример этого так же представлен ниже, через ValidationError

    Пару слов насчёт обращения к словарю:
    на случай, если нет элемента в словаре в ходе работы,
    используют метод get, чтобы обработать такое событие
    но у нас и словаря с очищенными данными не будет, если
    мы не вписывали слаг, класс его в любом случае создаст,
    может и с пустым значением, но с ключом

    в urls было написано, почему нам нельзя имя тега create

    Если мы хотим изменить атрибуты html-элементов, которые
    генерирются рендером джанго, то делать это нужно через
    метод update и передаваемый ему словарь с ключами атрибутами
    и значениями ключей - значениями соответствующих атрибутов

    Вообще, генерация заполняемых элементов довольно интересный
    момент, в tag_create.html указано, как это делать
    внутри переданного в контекст form уже есть атрибуты, которые
    возвращают html-код, вот как раз атрибуты элементов внутри
    экзепляра мы и меняем внутри класса

    ---------
    В джанго так же предусмотрена возможность создания формы
    на основе существующей модели, тогда нужно наследоваться от
    forms.ModelForm и связать подклассом поля, как показано
    на примере ниже

    Пример описания атрибутов html объектов и вытаскивания
    самих полей есть

    Так же, метод save тоже подтягивается

    ---------
    Хорошей идеей будет описать логику сохранения экземпляров
    моделей уже внутри класса формы, что выше и сделано
"""